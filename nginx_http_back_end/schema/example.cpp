////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by slothjson. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#include "example.h"

namespace slothjson {

fxxx_gfw_t::fxxx_gfw_t()
{
    bool_val = true;
    __skip_bool_val = false;
    __json_has_bool_val = false;

    int8_val = 'a';
    __skip_int8_val = false;
    __json_has_int8_val = false;

    int32_val = -111111;
    __skip_int32_val = false;
    __json_has_int32_val = false;

    uint64_val = 0xffff;
    __skip_uint64_val = false;
    __json_has_uint64_val = false;

    double_val = 111111.111111;
    __skip_double_val = false;
    __json_has_double_val = false;

    str_val = "test";
    __skip_str_val = false;
    __json_has_str_val = false;

    __skip_vec_val = false;
    __json_has_vec_val = false;

    __skip_dict_val = false;
    __json_has_dict_val = false;
}

fxxx_gfw_t& fxxx_gfw_t::operator=(const fxxx_gfw_t& obj_val)
{
    this->bool_val = obj_val.bool_val;
    this->int8_val = obj_val.int8_val;
    this->int32_val = obj_val.int32_val;
    this->uint64_val = obj_val.uint64_val;
    this->double_val = obj_val.double_val;
    this->str_val = obj_val.str_val;
    this->vec_val = obj_val.vec_val;
    this->dict_val = obj_val.dict_val;
    return *this;
}

bool fxxx_gfw_t::operator==(const fxxx_gfw_t& obj_val) const
{
    if (!(this->bool_val == obj_val.bool_val)) return false;
    if (!(this->int8_val == obj_val.int8_val)) return false;
    if (!(this->int32_val == obj_val.int32_val)) return false;
    if (!(this->uint64_val == obj_val.uint64_val)) return false;
    if (!(this->double_val == obj_val.double_val)) return false;
    if (!(this->str_val == obj_val.str_val)) return false;
    if (!(this->vec_val == obj_val.vec_val)) return false;
    if (!(this->dict_val == obj_val.dict_val)) return false;
    return true;
}

bool fxxx_gfw_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_bool_val && !encode_field(bool_val, "bool_val", alloc, json_val)) break;
        if (!__skip_int8_val && !encode_field(int8_val, "int8_val", alloc, json_val)) break;
        if (!__skip_int32_val && !encode_field(int32_val, "int32_val", alloc, json_val)) break;
        if (!__skip_uint64_val && !encode_field(uint64_val, "uint64_val", alloc, json_val)) break;
        if (!__skip_double_val && !encode_field(double_val, "double_val", alloc, json_val)) break;
        if (!__skip_str_val && !encode_field(str_val, "str_val", alloc, json_val)) break;
        if (!__skip_vec_val && !encode_field(vec_val, "vec_val", alloc, json_val)) break;
        if (!__skip_dict_val && !encode_field(dict_val, "dict_val", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool fxxx_gfw_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!decode_field(json_val, "bool_val", bool_val, __json_has_bool_val)) break;
        if (!decode_field(json_val, "int8_val", int8_val, __json_has_int8_val)) break;
        if (!decode_field(json_val, "int32_val", int32_val, __json_has_int32_val)) break;
        if (!decode_field(json_val, "uint64_val", uint64_val, __json_has_uint64_val)) break;
        if (!decode_field(json_val, "double_val", double_val, __json_has_double_val)) break;
        if (!decode_field(json_val, "str_val", str_val, __json_has_str_val)) break;
        if (!decode_field(json_val, "vec_val", vec_val, __json_has_vec_val)) break;
        if (!decode_field(json_val, "dict_val", dict_val, __json_has_dict_val)) break;

        return true;
    } while (0);

    return false;
}

bool encode(const fxxx_gfw_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, fxxx_gfw_t& obj_val)
{
    return obj_val.decode(json_val);
}

} // namespace slothjson