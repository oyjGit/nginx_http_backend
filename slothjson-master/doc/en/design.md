Design
--

Keywords: `third-party json parser` & `base library` & `code generator`

![design](../../res/design.png)

### Principle ###
The design of slothjson is based on this principle: the object instance of any type, which is defined as C++ struct, **could be expanded to an objects-tree recursively**.

For instance, if we define a struct named `root_t` like this:

	struct base_t
	{
	    int32_t int32_val;
	    std::string str_val;
	}
	
	struct root_t
	{
	    int64_t int64_val;
	    bool bool_val;
	    base_t base_val;
	}

and create the instance:

    root_t root_obj;

the expanded objects-tree is like this:

`root_obj (root_t)`  
　　`int64_val (int64_t)`  
　　`bool_val (bool)`  
　　`base_val (base_t)`  
　　　　`int32_val (int32_t)`  
　　　　`str_val (std::string)`  

As it states, both `root_obj` and `base_val` are instances of user-defined types, which are the **composite nodes** in objects-tree, while others are **leaf nodes**, such as `int64_val`, `bool_val` (built-in types in C++) and so on.

### Deductive ###

Based on the principle above, it can be divided into the following sub-problems to work well on JSON serialize/deserialize for C++ object:

1. Implement the JSON serialize/deserialize interfaces for **leaf nodes**;
2. Implement the JSON serialize/deserialize interfaces for **composite nodes** based on `1`.

More specific, the 1-st sub-problem requires JSON serialize/deserialize interfaces of C++ built-in types as following:  

* `bool`
* `int8_t`  
* `uint8_t`  
* `int16_t`  
* `uint16_t`  
* `int32_t`  
* `uint32_t`  
* `int64_t`  
* `uint64_t`  
* `float`  
* `double`  
* `std::string`  

Strictly speaking, `std::string` is the built-in type of `STL`. We classify it as leaf nodes because it is widely used in production environment.

The 2-nd sub-problem requires JSON serialize/deserialize interfaces of user-defined types, including the following issues:

* Implements for composite nodes such as `root_t`, `base_t`
* Implements for array (any nested type)
* Implements for dict (any nested type)

### Design ###

It's easy to handle the 1-st sub-problem with the help of rapidjson (it has provided most interfaces for C++ build-in types) ^_^  
The 2-nd sub-problem, to implement JSON serialize/deserialize interfaces for composite nodes such as the instance of `root_t`, we can encode it to the `object` in JSON, using the name of each field as `object-key` (the name should not be duplicated), value as `object-value`. The key to such design lies in **traversing the object's fields in runtime**. There are three types of automation solutions for such problem:

1. reflection
2. macro
3. code generator

We need to bid farewell to the first solution as C++ does not support reflection inborn.  
PS: even C++ supports it, I will not take this solution into consideration due to its **bad performance** .

Macro sounds good, but it's hard to debug, extend, and maintain. Besides, it's a nightmare to build a large system full of macros.

So, the answer is code generator.

JSON serialize/deserialize interfaces for array and dict could be implemented with the help of `STL` built-in types:

* `std::vector <T>`
* `std::map <std::string, T>`

In summary, the design of slothjson includes the following items:

* For the C++ built-in types, we could implement the JSON serialize/deserialize interfaces with the help of third-party JSON parser (rapidjson)
* For the C++ built-in types not directly supported by third-party JSON parser (for example, `int8_t`), we could cast them to the supported types (type conversion)
* For the user-defined types, the implements could be generated by code generator
* Finally, implement the JSON serialize/deserialize interfaces for array and dict using the `STL` built-in types.

We will describe the design through interfaces defined in `slothjson.h`.

`rapidjson` defines type of `json` like this:

    rapidjson::Value

As a result, to support JSON serialization/deserialization, you need to implement the serialize/deserialize interfaces between instance of `rapidjson::Value` and other object (any type in C++):  

    namespace slothjson
	{
        template<typename T>
	    bool encode(const T& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
        template<typename T>
	    bool decode(const rapidjson::Value& json_val, T& obj_val);
    }

Comment: instance of `rapidjson::Value` depends on the object of this type:

	namespace slothjson
	{
	    typedef rapidjson::Document::AllocatorType allocator_t;
	}
So, the function `encode` depends on the instance of `allocator_t`.

Firstly, the serialize/deserialize interfaces on built-in types of `rapidjson` should be implemented:

	namespace slothjson
	{
	    bool encode(const bool& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, bool& obj_val);
	
	    bool encode(const std::string& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, std::string& obj_val);
	
	    bool encode(const int32_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, int32_t& obj_val);
	
	    bool encode(const uint32_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, uint32_t& obj_val);
	
	    bool encode(const double& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, double & obj_val);
	
	    bool encode(const int64_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, int64_t& obj_val);
	
	    bool encode(const uint64_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, uint64_t& obj_val);
	}

Secondly, try to adapt non-built-in types to built-in types:

    namespace slothjson
	{
	    bool encode(const int8_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, int8_t& obj_val);
	
	    bool encode(const uint8_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, uint8_t& obj_val);
	
	    bool encode(const int16_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, int16_t& obj_val);
	
	    bool encode(const uint16_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, uint16_t& obj_val);
	
	    bool encode(const float& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    bool decode(const rapidjson::Value& json_val, float & obj_val);
	}

With the support of template in C++, we could implement the interfaces of array and dict:

	namespace slothjson
	{
	    template<typename T>
	    bool encode(const std::vector<T>& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    template<typename T>
	    bool decode(const rapidjson::Value& json_val, std::vector<T>& obj_val);
	
	    template<typename T>
	    bool encode(const std::map<std::string, T>& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    template<typename T>
	    bool decode(const rapidjson::Value& json_val, std::map<std::string, T>& obj_val);
	} 

What we should do next is to provide the serialize/deserialize interfaces for fields in object to simplify the design of code generator:

    namespace slothjson
	{
	    template<typename T>
	    bool encode_field(const T& field, const char * field_name, allocator_t& alloc, rapidjson::Value& json_val);
	    template<typename T>
	    bool decode_field(const rapidjson::Value& json_val, const char * field_name, T& field, bool& field_in_json);
	}

Finally, defines the user-interfaces like this:

	namespace slothjson
	{
	    template<bool pretty, typename T>
	    bool encode(const T& obj_val, std::string& json_val);
	    template<typename T>
	    bool decode(const std::string& json_val, T& obj_val);
	}
	
	namespace slothjson
	{
	    template<bool pretty, typename T>
	    bool dump(const T& obj_val, const char * path);
	
	    template<typename T>
	    bool load(const char * path, T& obj_val);
	};

Now the foundational library has been done.

Further, for user-defined types like this:

	struct perf_object_t
	{
	    bool bool_val;
	    int8_t int8_val;
	    uint8_t uint8_val;
	    int16_t int16_val;
	    uint16_t uint16_val;
	    int32_t int32_val;
	    uint32_t uint32_val;
	    int64_t int64_val;
	    uint64_t uint64_val;
	    float float_val;
	    double double_val;
	    std::string str_val;
	    std::vector<int32_t > vec_val;
	    std::map<std::string, std::string > dict_val;
	}

We only have to implement the following interfaces to support JSON serialize/deserialize:

    bool encode(const perf_object_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
    bool decode(const rapidjson::Value& json_val, perf_object_t& obj_val);

We could code like this:

    bool perf_object_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
	{
	    do
	    {
	        json_val.SetObject();
	        if (!__skip_bool_val && !encode_field(bool_val, "bool_val", alloc, json_val)) break;
	        if (!__skip_int8_val && !encode_field(int8_val, "int8_val", alloc, json_val)) break;
	        if (!__skip_uint8_val && !encode_field(uint8_val, "uint8_val", alloc, json_val)) break;
	        if (!__skip_int16_val && !encode_field(int16_val, "int16_val", alloc, json_val)) break;
	        if (!__skip_uint16_val && !encode_field(uint16_val, "uint16_val", alloc, json_val)) break;
	        if (!__skip_int32_val && !encode_field(int32_val, "int32_val", alloc, json_val)) break;
	        if (!__skip_uint32_val && !encode_field(uint32_val, "uint32_val", alloc, json_val)) break;
	        if (!__skip_int64_val && !encode_field(int64_val, "int64_val", alloc, json_val)) break;
	        if (!__skip_uint64_val && !encode_field(uint64_val, "uint64_val", alloc, json_val)) break;
	        if (!__skip_float_val && !encode_field(float_val, "float_val", alloc, json_val)) break;
	        if (!__skip_double_val && !encode_field(double_val, "double_val", alloc, json_val)) break;
	        if (!__skip_str_val && !encode_field(str_val, "str_val", alloc, json_val)) break;
	        if (!__skip_vec_val && !encode_field(vec_val, "vec_val", alloc, json_val)) break;
	        if (!__skip_dict_val && !encode_field(dict_val, "dict_val", alloc, json_val)) break;
	
	        return true;
	    } while (0);
	
	    return false;
	}
	
	bool perf_object_t::decode(const rapidjson::Value& json_val)
	{
	    do
	    {
	        if (!decode_field(json_val, "bool_val", bool_val, __json_has_bool_val)) break;
	        if (!decode_field(json_val, "int8_val", int8_val, __json_has_int8_val)) break;
	        if (!decode_field(json_val, "uint8_val", uint8_val, __json_has_uint8_val)) break;
	        if (!decode_field(json_val, "int16_val", int16_val, __json_has_int16_val)) break;
	        if (!decode_field(json_val, "uint16_val", uint16_val, __json_has_uint16_val)) break;
	        if (!decode_field(json_val, "int32_val", int32_val, __json_has_int32_val)) break;
	        if (!decode_field(json_val, "uint32_val", uint32_val, __json_has_uint32_val)) break;
	        if (!decode_field(json_val, "int64_val", int64_val, __json_has_int64_val)) break;
	        if (!decode_field(json_val, "uint64_val", uint64_val, __json_has_uint64_val)) break;
	        if (!decode_field(json_val, "float_val", float_val, __json_has_float_val)) break;
	        if (!decode_field(json_val, "double_val", double_val, __json_has_double_val)) break;
	        if (!decode_field(json_val, "str_val", str_val, __json_has_str_val)) break;
	        if (!decode_field(json_val, "vec_val", vec_val, __json_has_vec_val)) break;
	        if (!decode_field(json_val, "dict_val", dict_val, __json_has_dict_val)) break;
	
	        return true;
	    } while (0);
	
	    return false;
	}
    
    bool encode(const perf_object_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
	{
	    return obj_val.encode(alloc, json_val);
	}
	
	bool decode(const rapidjson::Value& json_val, perf_object_t& obj_val)
	{
	    return obj_val.decode(json_val);
	}

`__skip_xxx`  is used to encode field optional, while `__json_has_xxx` is used to decode field optional (tag whether the field is in JSON).  
The solution above is to encode the object to instance of `object` type in `json` by traversing all fields of object, using field name as `object-key`, field value as `object-value`. The automation could be supported by [schema and code generator](schema.md).

[Previous](../../README.md)

[Home](../../README.md)