FAQ
--

### Q: 为什么叫做 slothjson？ ###
因为作者是懒人。  
树獭几乎就是懒的代名词，刚好这套工具用于 `json`，于是叫做 `slothjson`。  
作者深信： **懒是程序员进步的源动力**  ^_^。

### Q: 为什么用 rapidjson？ 打算支持 jsoncpp 吗？ ###
因为性能。经测试，`rapidjson` 在生产环境中编解码的时间开销要比 `jsoncpp` **低一倍** 以上。  
当然，`jsoncpp` 提供的接口要比 `rapidjson` 友好很多。如果它的性能能赶上甚至超越后者，作者会增加对 `jsoncpp` 的支持。代码我有，但是我不放出来。 ^_^  
PS: **如果你看懂了 `slothjson` 的设计方法，自己撸一个 `jsoncpp` 的实现是非常容易的** ，也就几百行代码的量。事实上 `slothjson` 最原始的版本就是基于 `jsoncpp` 做的。

### Q: 为什么使用 json 作为数据描述文件？为什么不用类似 [protobuf](https://github.com/google/protobuf) 的做法？ ###
因为作者是懒人，懒得去写 `DSL` 解析器。而且没有必要。   
第一，`json` 作为事实上的工业标准，**基本上没有任何学习的门槛**，这一点非常重要。  
第二，`json` 是 **树形语法**，在语义构造方面有着 **极强的“柔性”** ，我们可以轻易地用它构造出函数、变量、条件判断语义；类、属性、方法语义；甚至可以构造出关系模型的 `select`、`where` 语义，`make` 的 `target`、`depends` 语义，等等数不清的语义。有了这么好的工具，何苦重新再造一门 `DSL` 来增加使用者的心智成本呢？  
第三，`protobuf`的 `DSL` 很好很强大，但别忘了，它亲爹是 `google` ， **背后有一个强大的团队来精心打造它** 。这对于 `google` 而言没有任何难度。但是对于我等普通的民间开发者而言，太庞大了，这个工程。要知道， **设计并实现一门语言，只有 `google` 这种级别的公司才可以做到如此任性** 。比如，最新的 [`flatbuffers`](https://github.com/google/flatbuffers)。基本上在这个行业，只要打上 `google` 的标签，很难不成为工业级标准，所以它可以不鸟 `json`，任性地造出很多 `DSL`。  
所以，这个问题甚至可以升级为：  
**当我们需要设计一门 `DSL` 时，为何不直接用 `json` 呢？**  
作者选择直接用 `json` 。因为第一不用写语法解析器（`python` 天然对 `json` 友好），第二不用担心语义构造的柔性。最重要的，如果你选择重新发明一门 `DSL`，第一你需要自己去实现语法解析，这将是一个艰巨的任务，第二，其学习成本 **未必比直接用 `json` 来的低** ，第三， **你当你是 `google` 啊，自己发明一个 `DSL` 就一定有人用** ？这才是最坑爹的地方。。。  

### Q: 为什么一个数据描述文件对应生成 .h 和 .cpp 两个文件？为什么不学类似 [flatbuffers](https://github.com/google/flatbuffers) 的做法合并到一个头文件中？ ###
为了节省你编译链接的时间。防止你因为等待的时间过长而砸电脑。 ^_^  
如果你接触过这样类似的项目：消息系统极其庞大，消息种类 **超过 500 个** ，平均每个消息的 **字段超过 5 个** ，那么数据描述文件对应的便是 500 个以上的 `struct`，且每个 `struct` 含 5 个以上的字段。如果生成的代码全部都在一个头文件里（或者分散在很多头文件，但是接口和实现是没有分离的），那么当你重新构建项目的时候，你几乎可以睡一个午觉了。或者当你修改过一个头文件，打算重新构建一次项目，哈哈，恭喜你，很可能这个时间足够你慢慢地喝几杯咖啡了。  
作者便曾经参与过这样的项目。最开始的做法就是不分离实现，全部在头文件中搞定。结果是，项目完整构建一次需要 **160 分钟**，增量构建一次需要 **20 分钟**。后来替换成分离式的做法后，完整构建只需要 **40 分钟**，增量构建只需要 **5 分钟**。前后压缩了接近 **80%** 的时间。这是多么伟大的生产力的解放啊~~~  
作者总结的经验是：所有的实现都合并在一个 `cpp` 中，构建的时间相对而言是最短的。

### Q: 为什么不支持更多的数据类型？比如 std::list、enum、union ###
曾经支持过很多类型，甚至支持过 `boost::uuid` ，后来都去掉了，只保留了必须支持的 [12种类型](schema/types.md) （作者现在觉得还可以再砍，比如 `float`）。  
因为作者是懒人。  
而且，`slothjson` 的基础库应该保持 **尽可能的简单** 。所有第三方的类型都可以通过 **适配** 为 `slothjson` 所支持的类型来达到目的。  
例如，`enum` 可以通过适配为 `int32_t` 来达到目的。  
得益于此，`slothjson.h` 和 `slothjson.cpp`  **加起来也一共才700多行代码** ，不用依赖任何第三方的库（除了 `rapidjson`），非常轻量级。这就是做减法的好处。（比如以前曾支持过的 `boost::uuid`，需要依赖什么，你懂得 ^_^）  
如果一定要支持更多的数据类型，比如 `std::list`，自己新建一个文件（比如，`slothjson_wrap.h`），实现以下两个接口吧：

    namespace slothjson
    {
	    template<typename T>
	    bool encode(const std::list<T>& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
	    template<typename T>
	    bool decode(const rapidjson::Value& json_val, std::list<T>& obj_val);
    }
实现方法可以参考 `slothjson.h` 和 `slothjson.cpp`。
所有的第三方类型，只要实现了这对接口，都可以无缝整合到 `slothjson` 中。但是，这些类型，都不是 `slothjson` 所 **必须具备** 的。例如，`union`。  
作者坚信：判断一个设计是否是好的设计，不在于是否还能增加多少功能， **而在于现有的功能是否减无可减** 。  

### Q: slothjson 支持命名空间、继承、模板等一系列 C++ 特性吗？ ###
曾经支持过。后来发现 **用到的地方极少极少** ，而且实现变得极其复杂，就去掉了。得益于此，代码生成器的实现变得极其简单，不到300行就搞定了。损失的地方肯定是有，这些花哨的特性不再支持了。但正因为这样做了减法，才保证了 `slothjson` 足够简单。  
作者认为，设计一个基础组件， **决定不做什么与决定做什么同等重要** 。  
万一要用这些特性怎么办？考虑重新设计吧。  
因为你真正需要的功能，`slothjson` 基本一个不少；  
`slothjson` 缺少的功能，基本都是不太重要的功能，或者可以用变通的方式解决。  
比如，命名空间（名字取长一点，加项目前缀），继承（用组合代替），模板（多定义几个名字不同的类型吧）。  

### Q: 一定要让 slothjson 支持更多的类型，更多的酷炫特性，怎么破？ ###
自行 `fork` 一个来完成吧。等你加完了你会发现，还是不加的好。 ^_^

[上一级](../../README_ZH.md)

[根目录](../../README_ZH.md)